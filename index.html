<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Quick Recipes</title>
  <link rel="icon" type="image/png" href="favicon.png" />
  <meta name="description" content="Instant semantic recipe search. Find your best recipe match in 3,895 dishes — all with full cooking instructions." />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />

  <!-- jsPDF and docx loaded on demand (see lazyJsPDF / lazyDocx) -->

  <style>
    :root {
      --bg: #f4f5f7;
      --surface: #ffffff;
      --surface2: #f0f1f4;
      --text: #111827;
      --text2: #4b5563;
      --border: #e5e7eb;
      --primary: #2563eb;
      --primary-light: #dbeafe;
      --primary-dark: #1d4ed8;
      --good: #059669;
      --good-light: #d1fae5;
      --warn: #d97706;
      --warn-light: #fef3c7;
      --danger: #dc2626;
      --danger-light: #fee2e2;
      --shadow-sm: 0 1px 2px rgba(0,0,0,.06);
      --shadow: 0 4px 12px rgba(0,0,0,.08);
      --shadow-lg: 0 12px 32px rgba(0,0,0,.12);
      --radius: 14px;
      --radius-sm: 10px;
      --nav-h: 56px;
    }

    [data-theme="dark"] {
      --bg: #0f1117;
      --surface: #1a1d27;
      --surface2: #23262f;
      --text: #f3f4f6;
      --text2: #9ca3af;
      --border: #2d3039;
      --primary: #60a5fa;
      --primary-light: rgba(96,165,250,.15);
      --primary-dark: #3b82f6;
      --good: #34d399;
      --good-light: rgba(52,211,153,.12);
      --warn: #fbbf24;
      --warn-light: rgba(251,191,36,.12);
      --danger: #f87171;
      --danger-light: rgba(248,113,113,.12);
      --shadow-sm: 0 1px 2px rgba(0,0,0,.2);
      --shadow: 0 4px 12px rgba(0,0,0,.3);
      --shadow-lg: 0 12px 32px rgba(0,0,0,.4);
    }

    *, *::before, *::after { box-sizing: border-box; }
    html { height: 100%; -webkit-text-size-adjust: 100%; }
    body {
      margin: 0;
      min-height: 100%;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      -webkit-font-smoothing: antialiased;
      line-height: 1.5;
    }
    a { color: var(--primary); text-decoration: none; }
    a:hover { text-decoration: underline; }

    /* ── TOP NAV ────────────────────────────── */
    .navbar {
      position: sticky; top: 0; z-index: 100;
      height: var(--nav-h);
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 0 16px;
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      box-shadow: var(--shadow-sm);
    }
    .nav-brand {
      font-size: 18px;
      font-weight: 900;
      letter-spacing: -.3px;
      margin-right: 16px;
      white-space: nowrap;
    }
    .nav-tabs { display: flex; gap: 2px; flex: 1; overflow-x: auto; }
    .nav-tab {
      padding: 8px 14px;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 700;
      color: var(--text2);
      background: transparent;
      border: none;
      cursor: pointer;
      white-space: nowrap;
      transition: background .15s, color .15s;
    }
    .nav-tab:hover { background: var(--surface2); }
    .nav-tab.active { background: var(--primary-light); color: var(--primary); }
    .nav-actions { display: flex; gap: 6px; align-items: center; }
    .icon-btn {
      width: 36px; height: 36px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--surface2);
      color: var(--text);
      display: flex; align-items: center; justify-content: center;
      cursor: pointer;
      font-size: 16px;
      transition: background .15s;
    }
    .icon-btn:hover { background: var(--border); }
    .bmac-link {
      display: flex; align-items: center; justify-content: center;
      width: 34px; height: 34px;
      border-radius: 8px;
      color: var(--text2);
      transition: color .15s, background .15s;
      text-decoration: none;
    }
    .bmac-link:hover { color: #d97706; background: var(--surface2); text-decoration: none; }
    .status-dot {
      width: 8px; height: 8px; border-radius: 50%;
      background: var(--warn);
      flex-shrink: 0;
    }
    .status-dot.ok { background: var(--good); }
    .status-dot.err { background: var(--danger); }

    /* ── LAYOUT ─────────────────────────────── */
    .container { max-width: 720px; margin: 0 auto; padding: 20px 16px 40px; }
    .container-wide { max-width: 960px; margin: 0 auto; padding: 20px 16px 40px; }
    .page { display: none; }
    .page.active { display: block; }

    /* ── COMMON ELEMENTS ────────────────────── */
    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 20px;
    }
    .card + .card { margin-top: 16px; }
    .card h2 { margin: 0 0 4px; font-size: 18px; font-weight: 900; }
    .card-sub { color: var(--text2); font-size: 13px; margin-bottom: 16px; }

    input, textarea, select {
      width: 100%;
      padding: 11px 14px;
      border-radius: var(--radius-sm);
      border: 1.5px solid var(--border);
      background: var(--surface);
      color: var(--text);
      font-size: 15px;
      outline: none;
      transition: border-color .15s, box-shadow .15s;
    }
    input:focus, textarea:focus, select:focus {
      border-color: var(--primary);
      box-shadow: 0 0 0 3px var(--primary-light);
    }
    textarea { min-height: 100px; resize: vertical; }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 11px 20px;
      border-radius: var(--radius-sm);
      border: 1.5px solid var(--border);
      background: var(--surface);
      color: var(--text);
      font-size: 14px;
      font-weight: 700;
      cursor: pointer;
      transition: all .12s;
      white-space: nowrap;
    }
    .btn:hover { background: var(--surface2); }
    .btn:active { transform: scale(.98); }
    .btn-primary {
      background: var(--primary);
      border-color: var(--primary);
      color: #fff;
    }
    .btn-primary:hover { background: var(--primary-dark); border-color: var(--primary-dark); }
    .btn-warn { background: var(--warn-light); border-color: var(--warn); color: var(--warn); }
    .btn-danger { background: var(--danger-light); border-color: var(--danger); color: var(--danger); }
    .btn-sm { padding: 7px 12px; font-size: 12px; }
    .btn-ghost { background: transparent; border-color: var(--border); }

    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .row > * { flex: 1; min-width: 0; }
    .row .shrink { flex: 0 0 auto; }
    .mt-12 { margin-top: 12px; }
    .mt-16 { margin-top: 16px; }
    .mt-20 { margin-top: 20px; }
    .muted { color: var(--text2); }
    .small { font-size: 13px; color: var(--text2); line-height: 1.5; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 13px; }
    .bold { font-weight: 800; }
    .hr { height: 1px; background: var(--border); margin: 16px 0; }
    .hidden { display: none !important; }

    .tag {
      display: inline-block;
      padding: 3px 10px;
      border-radius: 999px;
      background: var(--primary-light);
      color: var(--primary);
      font-size: 12px;
      font-weight: 700;
    }
    .tags { display: flex; gap: 6px; flex-wrap: wrap; margin-top: 8px; }

    /* ── PROGRESS BAR ───────────────────────── */
    .progress-wrap {
      width: 100%;
      height: 6px;
      border-radius: 999px;
      background: var(--surface2);
      overflow: hidden;
      margin-top: 8px;
    }
    .progress-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--primary), var(--good));
      border-radius: 999px;
      transition: width .3s ease;
    }

    /* ── SEARCH PAGE ────────────────────────── */
    .search-hero {
      text-align: center;
      padding: 32px 0 8px;
    }
    .search-hero h1 {
      font-size: 28px;
      font-weight: 900;
      letter-spacing: -.5px;
      margin: 0;
    }
    .search-hero p {
      color: var(--text2);
      font-size: 15px;
      margin: 6px 0 0;
    }
    @media (max-width: 480px) {
      .search-hero h1 { font-size: 22px; }
      .search-hero p { font-size: 13px; }
    }

    .search-box {
      display: flex;
      gap: 8px;
      margin-top: 20px;
    }
    .search-box input {
      flex: 1;
      font-size: 16px;
      padding: 14px 18px;
      border-radius: var(--radius);
      border: 2px solid var(--border);
      box-shadow: var(--shadow);
    }
    .search-box input:focus {
      border-color: var(--primary);
      box-shadow: var(--shadow), 0 0 0 3px var(--primary-light);
    }
    .search-box .btn {
      padding: 14px 28px;
      font-size: 16px;
      border-radius: var(--radius);
    }

    .status-bar {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 14px;
      border-radius: var(--radius-sm);
      background: var(--surface2);
      border: 1px solid var(--border);
      margin-top: 12px;
      font-size: 13px;
      color: var(--text2);
    }

    .filters-row {
      display: flex;
      gap: 10px;
      margin-top: 12px;
      flex-wrap: wrap;
    }
    .filters-row > div { flex: 1; min-width: 140px; }
    .filters-row label { display: block; font-size: 12px; font-weight: 700; color: var(--text2); margin-bottom: 4px; }
    .filters-row select { font-size: 13px; padding: 8px 10px; }

    .filter-toggle {
      display: flex; align-items: center; gap: 10px;
      margin-top: 12px;
      padding: 10px 14px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      background: var(--surface);
      cursor: pointer;
    }
    .filter-toggle .label { flex: 1; font-weight: 800; font-size: 14px; }
    .switch {
      width: 42px; height: 24px; border-radius: 999px;
      background: var(--surface2); border: 1.5px solid var(--border);
      position: relative; transition: background .2s, border-color .2s;
      flex-shrink: 0;
    }
    .switch .knob {
      width: 18px; height: 18px; border-radius: 999px;
      background: #fff; border: 1px solid var(--border);
      position: absolute; top: 2px; left: 2px;
      transition: left .2s; box-shadow: var(--shadow-sm);
    }
    .switch.on { background: var(--primary); border-color: var(--primary); }
    .switch.on .knob { left: 20px; }

    /* ── RESULT CARD ────────────────────────── */
    .result-card { margin-top: 20px; }
    .result-title {
      font-size: 22px;
      font-weight: 900;
      margin: 0;
      letter-spacing: -.3px;
    }
    .result-meta {
      display: flex; gap: 12px; align-items: center; flex-wrap: wrap;
      margin-top: 6px; font-size: 13px; color: var(--text2);
    }
    .match-badge {
      display: inline-flex; align-items: center; gap: 4px;
      padding: 2px 10px; border-radius: 999px;
      background: var(--good-light); color: var(--good);
      font-weight: 800; font-size: 12px;
    }
    .section-heading {
      font-size: 15px;
      font-weight: 900;
      margin: 20px 0 8px;
      text-transform: uppercase;
      letter-spacing: .5px;
      color: var(--text2);
    }
    .ingredient-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .ingredient-list li {
      padding: 7px 0;
      border-bottom: 1px solid var(--border);
      font-size: 14px;
      line-height: 1.5;
    }
    .ingredient-list li:last-child { border-bottom: none; }
    .ingredient-list li::before {
      content: "";
      display: inline-block;
      width: 6px; height: 6px;
      border-radius: 50%;
      background: var(--primary);
      margin-right: 10px;
      vertical-align: middle;
    }
    .instructions-list {
      list-style: none;
      padding: 0;
      margin: 0;
      counter-reset: step-counter;
    }
    .instructions-list li {
      counter-increment: step-counter;
      display: flex;
      gap: 14px;
      padding: 12px 0;
      border-bottom: 1px solid var(--border);
      font-size: 14px;
      line-height: 1.7;
      color: var(--text);
      word-break: break-word;
    }
    .instructions-list li:last-child { border-bottom: none; }
    .instructions-list li::before {
      content: counter(step-counter);
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: var(--primary);
      color: #fff;
      font-size: 13px;
      font-weight: 700;
      margin-top: 1px;
    }
    .instructions-text {
      font-size: 14px;
      line-height: 1.7;
      color: var(--text);
      white-space: pre-wrap;
      word-break: break-word;
    }
    .no-instructions {
      font-size: 13px;
      color: var(--text2);
      font-style: italic;
    }
    .result-actions { display: flex; gap: 8px; margin-top: 20px; flex-wrap: wrap; }

    /* ── LISTS (My Recipes, Plan, Shop) ───── */
    .list { margin-top: 12px; display: flex; flex-direction: column; gap: 8px; }
    .list-item {
      display: flex; gap: 10px; align-items: flex-start; justify-content: space-between;
      padding: 12px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      background: var(--surface);
      cursor: pointer;
      transition: box-shadow .12s;
    }
    .list-item:hover { box-shadow: var(--shadow); }
    .list-item h3 { margin: 0; font-size: 14px; font-weight: 800; }
    .list-item .meta { font-size: 12px; color: var(--text2); margin-top: 2px; }

    .check-row {
      display: flex; gap: 10px; align-items: flex-start;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      background: var(--surface);
    }
    .check-row input[type="checkbox"] {
      width: 18px; height: 18px; margin-top: 2px;
      accent-color: var(--primary);
      flex-shrink: 0;
    }
    .check-row .text { flex: 1; }
    .strike { text-decoration: line-through; opacity: .5; }

    /* ── RESPONSIVE ─────────────────────────── */
    @media (max-width: 640px) {
      .navbar { padding: 0 10px; }
      .nav-brand { font-size: 15px; margin-right: 8px; }
      .nav-tab { padding: 6px 10px; font-size: 12px; }
      .search-box { flex-direction: column; }
      .search-box .btn { width: 100%; }
      .container { padding: 12px 12px 32px; }
      .result-title { font-size: 18px; }
    }

    /* Two-column layout for planner/my-recipes on desktop */
    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }
    @media (max-width: 780px) {
      .grid-2 { grid-template-columns: 1fr; }
    }
  </style>
</head>

<body>
  <!-- ── NAVBAR ──────────────────────────────── -->
  <nav class="navbar">
    <div class="nav-brand">Quick Recipes</div>
    <div class="nav-tabs">
      <button class="nav-tab active" data-tab="Search">Search</button>
      <button class="nav-tab" data-tab="MyRecipes">My Recipes</button>
      <button class="nav-tab" data-tab="Planner">Planner</button>
      <button class="nav-tab" data-tab="Settings">Settings</button>
    </div>
    <div class="nav-actions">
      <div class="status-dot" id="statusDot" title="Dataset not loaded"></div>
      <a href="https://buymeacoffee.com/craigwinter" target="_blank" rel="noopener" class="bmac-link" title="Buy me a coffee">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 8h1a4 4 0 0 1 0 8h-1"/><path d="M3 8h14v9a4 4 0 0 1-4 4H7a4 4 0 0 1-4-4Z"/><line x1="6" y1="2" x2="6" y2="4"/><line x1="10" y1="2" x2="10" y2="4"/><line x1="14" y1="2" x2="14" y2="4"/></svg>
      </a>
      <button class="icon-btn" id="btnTheme" title="Toggle theme">&#9789;</button>
    </div>
  </nav>

  <!-- ═══════════════════════════════════════════
       SEARCH PAGE
  ═══════════════════════════════════════════════ -->
  <div id="pageSearch" class="page active">
    <div class="container">
      <div class="search-hero">
        <h1>What do you want to cook?</h1>
        <p>Search <span id="countText">3,895</span> recipes with full instructions.</p>
      </div>

      <div class="search-box">
        <input id="q" type="search" placeholder='Try "spicy chicken", "vegan dessert", "quick pasta no dairy"' autocomplete="off" />
        <button class="btn btn-primary" id="btnSearch">Search</button>
      </div>

      <div class="status-bar" id="statusBar">
        <div class="status-dot" id="statusDot2"></div>
        <div style="flex:1">
          <div id="statusText"><b>Loading...</b></div>
          <div class="small" id="statusSub">Downloading recipe data (one-time, cached after).</div>
        </div>
      </div>
      <div class="progress-wrap" id="progressWrap">
        <div class="progress-bar" id="bar"></div>
      </div>

      <!-- Filters (collapsible) -->
      <details class="mt-12" id="filterDetails">
        <summary style="cursor:pointer; font-weight:700; font-size:14px; color:var(--text2);">Filters &amp; Diet Mode</summary>

        <div class="filters-row">
          <div>
            <label>Tag filter</label>
            <input id="tagFilter" placeholder="e.g. vegan, soup, breakfast" style="font-size:13px; padding:8px 10px;" />
          </div>
          <div>
            <label>Diet preset</label>
            <select id="dietPreset">
              <option value="none">None</option>
              <option value="vegan">Vegan</option>
              <option value="vegetarian">Vegetarian</option>
              <option value="glutenfree">Gluten-free</option>
              <option value="dairyfree">Dairy-free</option>
              <option value="nutfree">Nut-free</option>
              <option value="keto">Keto</option>
              <option value="lowsodium">Low-sodium</option>
            </select>
          </div>
          <div>
            <label>Strictness</label>
            <select id="dietStrict">
              <option value="strict" selected>Strict (exclude)</option>
              <option value="soft">Soft (down-rank)</option>
            </select>
          </div>
        </div>

        <div class="filter-toggle mt-12" id="dietToggle">
          <div class="label">Enable diet filter</div>
          <div class="switch" id="dietSwitch" role="switch" aria-checked="false" tabindex="0">
            <div class="knob"></div>
          </div>
        </div>

      </details>

      <!-- RESULT -->
      <div id="resultCard" class="card result-card hidden">
        <div style="display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;">
          <h2 class="result-title" id="rTitle" style="flex:1; min-width:0;"></h2>
          <div style="display:flex; gap:6px;">
            <button class="btn btn-ghost btn-sm" id="btnPrev" title="Show previous match">&larr; Prev</button>
            <button class="btn btn-ghost btn-sm" id="btnNext" title="Show next match">Next &rarr;</button>
          </div>
        </div>
        <div class="result-meta">
          <span id="rMatchBadge" class="match-badge"></span>
          <span id="rResultNum" class="small"></span>
          <span id="rSource"></span>
          <a id="rLink" href="#" target="_blank" rel="noreferrer" style="display:none">View source</a>
        </div>
        <div class="tags" id="rTags"></div>

        <div class="section-heading">Ingredients</div>
        <ul class="ingredient-list" id="rIngredients"></ul>

        <div class="section-heading">Instructions</div>
        <div id="rInstructions"></div>

        <div class="result-actions">
          <button class="btn btn-primary" id="btnAddToPlan">Add to Plan</button>
          <button class="btn" id="btnSaveAsMine">Save to My Recipes</button>
        </div>
      </div>
    </div>
  </div>

  <!-- ═══════════════════════════════════════════
       MY RECIPES PAGE
  ═══════════════════════════════════════════════ -->
  <div id="pageMyRecipes" class="page">
    <div class="container-wide">
      <div class="grid-2">
        <div class="card">
          <h2>My Recipes</h2>
          <div class="card-sub">Private to this browser. Create, edit, export.</div>

          <div class="row">
            <button class="btn btn-primary" id="btnNewMine">New Recipe</button>
            <button class="btn btn-sm" id="btnExportMineCSV">CSV</button>
            <button class="btn btn-sm" id="btnExportMinePDF">PDF</button>
            <button class="btn btn-sm" id="btnExportMineDOCX">DOCX</button>
          </div>
          <input id="mineSearch" placeholder="Search my recipes..." class="mt-12" />
          <div class="list" id="mineList"></div>
        </div>

        <div>
          <!-- Preview (read-only formatted view) -->
          <div class="card hidden" id="minePreviewCard">
            <div style="display:flex; align-items:center; justify-content:space-between; gap:8px; flex-wrap:wrap;">
              <h2 id="mpTitle" style="margin:0; flex:1; min-width:0;"></h2>
              <button class="btn btn-ghost btn-sm" id="btnMineEdit">Edit</button>
            </div>
            <div class="tags mt-12" id="mpTags"></div>
            <div class="section-heading">Ingredients</div>
            <ul class="ingredient-list" id="mpIngredients"></ul>
            <div class="section-heading">Instructions</div>
            <div id="mpInstructions"></div>
            <div id="mpNotes" class="mt-16" style="display:none">
              <div class="section-heading">Notes</div>
              <div class="instructions-text" id="mpNotesText"></div>
            </div>
          </div>

          <!-- Editor (toggled) -->
          <div class="card hidden" id="mineEditorCard">
            <h2>Edit Recipe</h2>
            <input id="mTitle" placeholder="Recipe title" />
            <div class="row mt-12">
              <input id="mTags" placeholder="Tags (comma separated)" />
              <input id="mTime" placeholder="Time, e.g. 20 min" style="max-width:140px" />
            </div>
            <textarea id="mIngredients" class="mt-12" placeholder="Ingredients (one per line)"></textarea>
            <textarea id="mSteps" class="mt-12" placeholder="Instructions / Steps"></textarea>
            <textarea id="mNotes" class="mt-12" placeholder="Notes (optional)"></textarea>
            <div class="row mt-12">
              <button class="btn btn-primary" id="btnSaveMine">Save</button>
              <button class="btn btn-danger btn-sm" id="btnDeleteMine">Delete</button>
              <button class="btn btn-ghost btn-sm" id="btnClearMine">Clear</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- ═══════════════════════════════════════════
       PLANNER PAGE
  ═══════════════════════════════════════════════ -->
  <div id="pagePlanner" class="page">
    <div class="container-wide">
      <div class="grid-2">
        <div class="card">
          <h2>Meal Planner</h2>
          <div class="card-sub">Schedule recipes and auto-generate a shopping list.</div>

          <div class="row">
            <div><label class="small bold">Date</label><input id="pDate" type="date" /></div>
            <div><label class="small bold">Meal</label>
              <select id="pMeal">
                <option>Breakfast</option><option>Lunch</option><option>Dinner</option><option>Snack</option>
              </select>
            </div>
            <div><label class="small bold">Servings</label><input id="pServings" type="number" min="1" value="2" /></div>
          </div>
          <div class="row mt-12">
            <input id="pPick" placeholder="Type a recipe title (from Search or My Recipes)" />
            <button class="btn btn-primary shrink" id="btnPlanAdd">Add</button>
          </div>
          <div class="row mt-12">
            <button class="btn btn-sm" id="btnPlanExportCSV">CSV</button>
            <button class="btn btn-sm" id="btnPlanExportPDF">PDF</button>
            <button class="btn btn-sm" id="btnPlanExportDOCX">DOCX</button>
          </div>
          <div class="status-bar mt-12"><span id="planStatus">Ready.</span></div>
          <div class="list" id="planList"></div>
        </div>

        <div class="card">
          <h2>Shopping List</h2>
          <div class="card-sub">Auto-generated from plan + manual items. Editable.</div>

          <div class="row">
            <input id="shopNew" placeholder="Add item, e.g. 2 lemons" />
            <button class="btn btn-primary shrink" id="btnShopAdd">Add</button>
          </div>
          <div class="row mt-12">
            <button class="btn btn-sm" id="btnShopExportCSV">CSV</button>
            <button class="btn btn-sm" id="btnShopExportPDF">PDF</button>
            <button class="btn btn-sm" id="btnShopExportDOCX">DOCX</button>
            <button class="btn btn-ghost btn-sm" id="btnShopClearDone">Clear checked</button>
            <button class="btn btn-danger btn-sm" id="btnShopWipe">Wipe</button>
          </div>
          <button class="btn btn-warn btn-sm mt-12" id="btnRebuildShop">Rebuild from plan</button>
          <div class="list" id="shopList"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- ═══════════════════════════════════════════
       SETTINGS PAGE
  ═══════════════════════════════════════════════ -->
  <div id="pageSettings" class="page">
    <div class="container">
      <div class="card">
        <h2>Data</h2>
        <div class="card-sub">All personal data stays in your browser (IndexedDB). Nothing is sent to a server.</div>
        <div class="row">
          <button class="btn btn-primary" id="btnExportAll">Export ALL (JSON)</button>
          <button class="btn" id="btnImportAll">Import (JSON)</button>
          <input id="filePick" type="file" accept="application/json" style="display:none" />
        </div>
        <div class="row mt-16">
          <button class="btn btn-danger" id="btnWipeUserData">Wipe all user data</button>
        </div>
      </div>
      <div class="card">
        <h2>About</h2>
        <div class="small">
          <p>Semantic search over <b>3,895 recipes</b> (all with full cooking instructions) using prebuilt AI embeddings (Xenova/all-MiniLM-L6-v2). Runs entirely in your browser — no server needed.</p>
          <p style="margin-top:12px">
            <a href="https://buymeacoffee.com/craigwinter" target="_blank" rel="noopener" style="display:inline-flex;align-items:center;gap:8px;background:#FFDD00;color:#000;font-weight:700;padding:8px 16px;border-radius:8px;text-decoration:none;font-size:14px;">
              <svg width="20" height="20" viewBox="0 0 884 1279" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M792 74c-17-4-45 0-45 0s-8-53-82-72C590-16 550 25 540 36c-8-4-36-14-80-14s-72 10-80 14C370 25 330-16 255 2c-74 19-82 72-82 72s-28-4-45 0-38 37-30 53 45 36 45 36-5 17-5 40v106c0 130 85 229 197 271v249H337c-25 0-69 8-69 72v234c0 18 14 34 32 34h284c18 0 32-16 32-34V619c0-64-44-72-69-72h-98V298c112-42 197-141 197-271V0s37-20 45-36 -13-49-30-53z" fill="#000"/></svg>
              Buy me a coffee
            </a>
          </p>
        </div>
        <div class="small mt-16" style="border-top:1px solid var(--border);padding-top:12px;">
          <p><b>License</b></p>
          <p>App code: <a href="https://github.com/IhaveAnIdea/quick-recipes/blob/master/LICENSE" target="_blank" rel="noopener">MIT License</a> — free to use with attribution.</p>
          <p style="margin-top:8px"><b>Recipe Data Attribution</b></p>
          <p><a href="https://en.wikibooks.org/wiki/Cookbook:Recipes" target="_blank" rel="noopener">Wikibooks Cookbook</a> — <a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener">CC BY-SA 4.0</a></p>
          <p><a href="https://github.com/jakevdp/open-recipe-data" target="_blank" rel="noopener">Open Recipes / open-recipe-data</a> — <a href="https://creativecommons.org/licenses/by/3.0/" target="_blank" rel="noopener">CC BY 3.0</a></p>
          <p style="margin-top:8px"><a href="https://github.com/IhaveAnIdea/quick-recipes" target="_blank" rel="noopener">View source on GitHub</a></p>
        </div>
      </div>
    </div>
  </div>

<script type="module">
  /* ══════════════════════════════════════════════
     UTILITIES
  ══════════════════════════════════════════════ */
  const $ = id => document.getElementById(id);
  const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));
  const esc = (s="") => String(s).replace(/[&<>"']/g, c => ({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"})[c]);
  const uid = () => "u_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
  const todayISO = () => new Date().toISOString().slice(0,10);

  function setProgress(p) { $("bar").style.width = `${clamp(p,0,100)}%`; }
  function setStatus(msg, sub="") {
    $("statusText").innerHTML = `<b>${esc(msg)}</b>`;
    $("statusSub").textContent = sub;
  }

  window.addEventListener("unhandledrejection", e => {
    console.error("unhandledrejection", e.reason);
    setStatus("Error", String(e.reason?.message || e.reason || "Unknown"));
    setProgress(0);
  });
  window.addEventListener("error", e => {
    console.error("error", e.error || e.message);
    setStatus("Error", String(e.error?.message || e.message || "Unknown"));
    setProgress(0);
  });

  /* ── Theme ─────────────────────────────────── */
  function applyTheme(t) {
    document.documentElement.setAttribute("data-theme", t);
    localStorage.setItem("theme", t);
  }
  applyTheme(localStorage.getItem("theme") || "light");
  $("btnTheme").addEventListener("click", () => {
    const cur = document.documentElement.getAttribute("data-theme") || "light";
    applyTheme(cur === "light" ? "dark" : "light");
  });

  /* ── Top nav tabs ──────────────────────────── */
  const pages = {
    Search: $("pageSearch"),
    MyRecipes: $("pageMyRecipes"),
    Planner: $("pagePlanner"),
    Settings: $("pageSettings"),
  };
  function setTab(name) {
    Object.values(pages).forEach(p => p.classList.remove("active"));
    pages[name].classList.add("active");
    document.querySelectorAll(".nav-tab").forEach(t =>
      t.classList.toggle("active", t.dataset.tab === name)
    );
  }
  document.querySelectorAll(".nav-tab").forEach(t =>
    t.addEventListener("click", () => setTab(t.dataset.tab))
  );

  /* ══════════════════════════════════════════════
     INDEXEDDB — user data
  ══════════════════════════════════════════════ */
  const USER_DB = "recipe_planner_user_v1";
  const USER_VER = 1;
  const STORE_RECIPES = "my_recipes";
  const STORE_PLAN = "plan_items";
  const STORE_SHOP = "shopping_items";
  const STORE_PREFS = "prefs";

  function openUserDB() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(USER_DB, USER_VER);
      req.onupgradeneeded = () => {
        const db = req.result;
        if (!db.objectStoreNames.contains(STORE_RECIPES)) db.createObjectStore(STORE_RECIPES, { keyPath: "id" });
        if (!db.objectStoreNames.contains(STORE_PLAN)) db.createObjectStore(STORE_PLAN, { keyPath: "id" });
        if (!db.objectStoreNames.contains(STORE_SHOP)) db.createObjectStore(STORE_SHOP, { keyPath: "id" });
        if (!db.objectStoreNames.contains(STORE_PREFS)) db.createObjectStore(STORE_PREFS);
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }
  async function idbAll(store) {
    const db = await openUserDB();
    return new Promise((r, j) => { const q = db.transaction(store,"readonly").objectStore(store).getAll(); q.onsuccess=()=>r(q.result||[]); q.onerror=()=>j(q.error); });
  }
  async function idbPut(store, val, key) {
    const db = await openUserDB();
    return new Promise((r, j) => { const tx = db.transaction(store,"readwrite"); const q = (store===STORE_PREFS)?tx.objectStore(store).put(val,key):tx.objectStore(store).put(val); q.onsuccess=()=>r(true); q.onerror=()=>j(q.error); });
  }
  async function idbGet(store, key) {
    const db = await openUserDB();
    return new Promise((r, j) => { const q = db.transaction(store,"readonly").objectStore(store).get(key); q.onsuccess=()=>r(q.result); q.onerror=()=>j(q.error); });
  }
  async function idbDel(store, key) {
    const db = await openUserDB();
    return new Promise((r, j) => { const q = db.transaction(store,"readwrite").objectStore(store).delete(key); q.onsuccess=()=>r(true); q.onerror=()=>j(q.error); });
  }
  async function idbClear(store) {
    const db = await openUserDB();
    return new Promise((r, j) => { const q = db.transaction(store,"readwrite").objectStore(store).clear(); q.onsuccess=()=>r(true); q.onerror=()=>j(q.error); });
  }

  // Mobile detection — used for memory-safe choices throughout
  const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

  /* ══════════════════════════════════════════════
     ASSET CACHE (blobs in IndexedDB)
  ══════════════════════════════════════════════ */
  const ASSET_DB = "recipe_hnsw_assets_v1";
  const ASSET_VER = 1;
  const ASSET_STORE = "blobs";
  function openAssetDB() {
    return new Promise((r, j) => {
      const req = indexedDB.open(ASSET_DB, ASSET_VER);
      req.onupgradeneeded = () => { const db = req.result; if (!db.objectStoreNames.contains(ASSET_STORE)) db.createObjectStore(ASSET_STORE); };
      req.onsuccess = () => r(req.result);
      req.onerror = () => j(req.error);
    });
  }
  async function assetPut(key, val) {
    try {
      const db = await openAssetDB();
      return new Promise((r, j) => { const tx = db.transaction(ASSET_STORE,"readwrite"); tx.objectStore(ASSET_STORE).put(val,key); tx.oncomplete=()=>r(true); tx.onerror=()=>r(false); });
    } catch(e) { console.warn("[cache] write failed, continuing without cache:", e); return false; }
  }
  async function assetGet(key) {
    try {
      const db = await openAssetDB();
      return new Promise((r, j) => { const q = db.transaction(ASSET_STORE,"readonly").objectStore(ASSET_STORE).get(key); q.onsuccess=()=>r(q.result); q.onerror=()=>r(null); });
    } catch(e) { return null; }
  }
  async function assetDelete(key) {
    try {
      const db = await openAssetDB();
      return new Promise((r, j) => { const tx = db.transaction(ASSET_STORE,"readwrite"); tx.objectStore(ASSET_STORE).delete(key); tx.oncomplete=()=>r(true); tx.onerror=()=>r(false); });
    } catch(e) { return false; }
  }

  async function fetchWithProgress(url, onProgress, fetchOpts) {
    const res = await fetch(url, fetchOpts);
    if (!res.ok) throw new Error(`Fetch failed: ${url} (${res.status})`);
    const total = Number(res.headers.get("content-length")) || 0;
    if (!res.body || typeof res.body.getReader !== "function") {
      const buf = await res.arrayBuffer();
      if (onProgress) onProgress(buf.byteLength, total || buf.byteLength);
      return buf;
    }
    const reader = res.body.getReader();
    const chunks = []; let received = 0;
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      chunks.push(value);
      received += value.byteLength;
      if (onProgress) onProgress(received, total);
    }
    const out = new Uint8Array(received); let off = 0;
    for (const c of chunks) { out.set(c, off); off += c.byteLength; }
    return out.buffer;
  }

  async function fetchOrCache(url, cacheKey, pBase=0, pSpan=0, forceRefresh=false) {
    // On mobile, skip IndexedDB caching to avoid peak-memory double-buffering
    // that causes iOS Safari to jetsam-kill the tab. HTTP cache still helps.
    if (!isMobile && !forceRefresh) {
      const cached = await assetGet(cacheKey);
      if (cached) return cached;
    }
    const buf = await fetchWithProgress(url, (got, total) => {
      if (!pSpan) return;
      const p = total > 0 ? pBase + (got/total)*pSpan : pBase + Math.min(pSpan*.9, pSpan*(got/5e6));
      setProgress(p);
    }, forceRefresh ? { cache: "no-cache" } : undefined);
    if (!isMobile) await assetPut(cacheKey, buf);
    return buf;
  }

  /* ══════════════════════════════════════════════
     DIET RULES
  ══════════════════════════════════════════════ */
  const DIET_RULES = {
    vegan: [/\b(egg|eggs|milk|cheese|butter|yogurt|cream|whey|casein|honey|gelatin|beef|pork|chicken|turkey|fish|salmon|tuna|anchovy|shrimp|lamb|bacon)\b/i],
    vegetarian: [/\b(beef|pork|chicken|turkey|fish|salmon|tuna|anchovy|shrimp|lamb|bacon|gelatin)\b/i],
    glutenfree: [/\b(wheat|barley|rye|semolina|spelt|farro|bulgur|couscous|pasta|bread|flour|soy sauce)\b/i],
    dairyfree: [/\b(milk|cheese|butter|yogurt|cream|whey|casein|ghee)\b/i],
    nutfree: [/\b(almond|walnut|pecan|cashew|hazelnut|pistachio|peanut|nut)\b/i],
    keto: [/\b(sugar|honey|syrup|bread|pasta|rice|potato|flour|corn|tortilla|cereal)\b/i],
    lowsodium: [/\b(soy sauce|tamari|fish sauce|bouillon|stock cube|msg|salt|brine|cured)\b/i],
    none: []
  };
  function recipeTextForDiet(r) {
    return [r.title, (r.tags||[]).join(" "), r.ingredients, r.instructions, r.steps].filter(Boolean).join("\n");
  }
  function getDietState() {
    return {
      enabled: $("dietSwitch").classList.contains("on"),
      preset: $("dietPreset").value,
      strictness: $("dietStrict").value,
    };
  }
  function violatesDiet(r, diet) {
    if (!diet.enabled || diet.preset === "none") return false;
    const rules = DIET_RULES[diet.preset] || [];
    if (!rules.length) return false;
    return rules.some(re => re.test(recipeTextForDiet(r)));
  }

  $("dietToggle").addEventListener("click", () => {
    const on = !$("dietSwitch").classList.contains("on");
    $("dietSwitch").classList.toggle("on", on);
    $("dietSwitch").setAttribute("aria-checked", String(on));
  });

  /* ══════════════════════════════════════════════
     EMBEDDER (query + user recipes)
  ══════════════════════════════════════════════ */
  let extractor = null;
  let embedderFailed = false;
  const MODEL_ID = "Xenova/all-MiniLM-L6-v2";

  // Mobile: WASM + quantized q8 model (~6 MB) to stay within iOS memory budget.
  // Desktop: prefer WebGPU when available, full fp32 model (~23 MB).
  const useDevice = (!isMobile && navigator.gpu) ? "webgpu" : "wasm";
  const useDtype  = isMobile ? "q8" : "fp32";

  async function loadEmbedder() {
    if (extractor) return;
    if (embedderFailed) throw new Error("Embedding model failed to load. Reload the page to retry.");

    const sizeHint = isMobile ? "~6 MB" : "~23 MB";
    setStatus("Loading AI model...", `First time downloads ${sizeHint} model (cached after).`);
    setProgress(8);

    try {
      // v3.8.1 includes critical iOS Safari fix: uses non-JSEP WASM build
      // that avoids the WebKit ASYNCIFY bug causing 10 GB+ memory balloon.
      // See: https://github.com/huggingface/transformers.js/issues/1242
      const T = await import("https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.8.1/dist/transformers.min.js");
      const env = T.env || T.default?.env;
      if (env) {
        env.allowLocalModels = false;
        env.useBrowserCache = true;
        // Force single-threaded WASM on mobile to avoid SharedArrayBuffer
        // issues (requires COOP/COEP headers that GitHub Pages doesn't set).
        if (isMobile && env.backends?.onnx?.wasm) {
          env.backends.onnx.wasm.numThreads = 1;
        }
      }
      const pipe = T.pipeline || T.default?.pipeline;
      extractor = await pipe("feature-extraction", MODEL_ID, {
        pooling: "mean", normalize: true,
        device: useDevice,
        dtype: useDtype,
      });
      setProgress(0);
    } catch(e) {
      embedderFailed = true;
      console.error("[embedder] load failed:", e);
      throw new Error("Could not load the embedding model. Check your connection and reload.");
    }
  }

  async function embedText(text) {
    await loadEmbedder();
    const dim = builtMeta?.dim || 384;
    const out = await extractor(text, { pooling: "mean", normalize: true });

    let vec;
    if (out?.data) vec = new Float32Array(out.data);
    else if (out?.tolist) vec = new Float32Array(out.tolist().flat(Infinity));
    else if (Array.isArray(out)) vec = new Float32Array(out.flat(Infinity));
    else throw new Error("Unexpected embedding output.");

    // Safety: if the pipeline returned unpooled tokens ([1, seq_len, dim]),
    // manually mean-pool and L2-normalize to get a single dim-length vector.
    if (vec.length > dim * 1.5) {
      console.warn(`[embedText] got ${vec.length} values, expected ${dim}; mean-pooling manually.`);
      const tokens = Math.round(vec.length / dim);
      const pooled = new Float32Array(dim);
      for (let i = 0; i < dim; i++) {
        let sum = 0;
        for (let t = 0; t < tokens; t++) sum += vec[t * dim + i];
        pooled[i] = sum / tokens;
      }
      let n = 0;
      for (let i = 0; i < dim; i++) n += pooled[i] * pooled[i];
      n = Math.sqrt(n) || 1;
      for (let i = 0; i < dim; i++) pooled[i] /= n;
      vec = pooled;
    }

    console.log(`[embedText] "${text}" → ${vec.length} dims, sample: [${vec.slice(0,4).map(v=>v.toFixed(4)).join(", ")}]`);
    return vec;
  }

  function dot(a,b) { let s=0; for(let i=0;i<a.length;i++) s+=a[i]*b[i]; return s; }
  function norm(a) { return Math.sqrt(dot(a,a))||1; }
  function cosine(a,b) { return dot(a,b)/(norm(a)*norm(b)); }
  function floatToBase64(f32) { const u8=new Uint8Array(f32.buffer); let s=""; const ch=0x8000; for(let i=0;i<u8.length;i+=ch) s+=String.fromCharCode.apply(null,u8.subarray(i,i+ch)); return btoa(s); }
  function base64ToFloat(b64) { const bin=atob(b64); const u8=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i); return new Float32Array(u8.buffer); }
  function myRecipeToEmbedText(r) { return [r.title,(r.tags||[]).join(", "),r.ingredients,r.steps,r.notes].filter(Boolean).join("\n"); }

  /* ══════════════════════════════════════════════
     DATASET — brute-force cosine search
  ══════════════════════════════════════════════ */
  let builtMeta = null;
  let builtRecipes = [];
  let builtVectors = null;

  function bruteForceSearchRanked(queryVec, queryWords, diet, tagFilter, maxResults = 50) {
    const dim = builtMeta.dim;
    const count = builtMeta.count;
    const vecs = builtVectors;

    let qNorm = 0;
    for (let i = 0; i < dim; i++) qNorm += queryVec[i] * queryVec[i];
    qNorm = Math.sqrt(qNorm) || 1;

    const scored = [];

    for (let n = 0; n < count; n++) {
      const r = builtRecipes[n];
      if (!r) continue;

      // hard filters
      if (diet.enabled && diet.preset !== "none" && diet.strictness === "strict" && violatesDiet(r, diet)) continue;
      if (tagFilter && !(r.tags || []).join(" ").toLowerCase().includes(tagFilter)) continue;

      // cosine similarity
      const off = n * dim;
      let d = 0, vN = 0;
      for (let i = 0; i < dim; i++) {
        const v = vecs[off + i];
        d += queryVec[i] * v;
        vN += v * v;
      }
      vN = Math.sqrt(vN) || 1;
      const sem = d / (qNorm * vN);
      let score = sem;

      // keyword scoring
      let titleHits = 0;
      if (queryWords.length) {
        const titleLow = (r.title || "").toLowerCase();
        const ingLow = (r.ingredients || "").toLowerCase();
        const tagsLow = (r.tags || []).join(" ").toLowerCase();
        let bodyHits = 0;
        for (const w of queryWords) {
          if (titleLow.includes(w)) titleHits++;
          else if (ingLow.includes(w) || tagsLow.includes(w)) bodyHits++;
        }
        const totalHits = titleHits + bodyHits;
        if (totalHits === 0) {
          const penalty = sem > 0.45 ? 0.03 : sem > 0.30 ? 0.06 : 0.10;
          score -= penalty;
        } else {
          score += (titleHits / queryWords.length) * 0.15;
          score += (bodyHits / queryWords.length) * 0.04;
          if (totalHits === queryWords.length) score += 0.05;
        }
      }

      // soft diet penalty
      if (diet.enabled && diet.preset !== "none" && diet.strictness === "soft" && violatesDiet(r, diet)) {
        score -= 0.06;
      }

      scored.push({ recipe: r, score, sem, titleHit: titleHits > 0 ? 1 : 0 });
    }

    // Diagnostic: log top raw cosine scores
    const topByCosine = [...scored].sort((a,b) => b.sem - a.sem).slice(0, 8);
    console.log("[search] top 8 by raw cosine:", topByCosine.map(x =>
      `${x.recipe.title} (sem=${x.sem.toFixed(4)}, score=${x.score.toFixed(4)}, titleHit=${x.titleHit})`
    ));

    // Split into title-matching and semantic-only pools.
    const titlePool = scored.filter(x => x.titleHit).sort((a, b) => b.score - a.score);
    const semPool   = scored.filter(x => !x.titleHit).sort((a, b) => b.sem - a.sem);

    // Interleave: every 3 title matches, insert 1 top semantic match.
    // "fisherman" → fisherman titles first (few titles, semantics fill in).
    // "pasta meals" → pasta titles + spaghetti/lasagna/noodles mixed in.
    const results = [];
    const seen = new Set();
    let ti = 0, si = 0;
    while (results.length < maxResults && (ti < titlePool.length || si < semPool.length)) {
      for (let k = 0; k < 3 && ti < titlePool.length && results.length < maxResults; k++) {
        if (!seen.has(titlePool[ti].recipe)) {
          results.push(titlePool[ti]);
          seen.add(titlePool[ti].recipe);
        }
        ti++;
      }
      if (si < semPool.length && results.length < maxResults) {
        if (!seen.has(semPool[si].recipe)) {
          results.push(semPool[si]);
          seen.add(semPool[si].recipe);
        }
        si++;
      }
    }

    return results;
  }

  /* ── Ingredient formatting ─────────────────── */
  function formatIngredients(text) {
    if (!text) return [];
    const lines = text.split(/\n/).map(s => s.trim()).filter(Boolean);
    if (lines.length > 1) return lines.map(l => l.replace(/^[-•*]\s*/, ""));

    // single blob: split before quantity patterns (digit after a letter)
    const parts = text
      .replace(/(?<=[a-zA-Z),;.]) (?=\d+[\s/.-]|[½¼¾⅓⅔⅛⅜⅝⅞])/g, "\n")
      .split("\n")
      .map(s => s.trim())
      .filter(Boolean);

    // also split on ALL-CAPS section headers like "SAUSAGE GRAVY"
    const result = [];
    for (const part of parts) {
      if (/^[A-Z][A-Z\s]{2,}$/.test(part.trim())) {
        result.push(part.trim());
      } else {
        result.push(part);
      }
    }
    return result;
  }

  /* ── Instruction formatting ─────────────────── */
  function formatInstructions(text) {
    if (!text) return [];
    // Try splitting on newlines first
    let steps = text.split(/\n/).map(s => s.trim()).filter(Boolean);

    // If we got a single blob, try splitting on numbered patterns like "1." "2)" "Step 3:"
    if (steps.length <= 1) {
      steps = text
        .split(/(?=(?:^|\.\s+)\d{1,2}[\.\)]\s)|(?=\bstep\s+\d+)/i)
        .map(s => s.trim())
        .filter(Boolean);
    }

    // If still a single blob, split on sentence boundaries (". " followed by uppercase)
    if (steps.length <= 1 && text.length > 120) {
      steps = text
        .split(/\.(?=\s+[A-Z])/)
        .map((s, i, a) => (i < a.length - 1 ? s.trim() + "." : s.trim()))
        .filter(s => s.length > 2);
    }

    // Clean up: strip leading numbering, bullets, "step N:" prefixes
    return steps.map(s =>
      s.replace(/^\d{1,2}[\.\)]\s*/, "")
       .replace(/^step\s+\d+[:\.\)]\s*/i, "")
       .replace(/^[-•*]\s*/, "")
       .trim()
    ).filter(Boolean);
  }

  /* ── Show result card ──────────────────────── */
  function showResult(recipe, score) {
    $("resultCard").classList.remove("hidden");
    $("rTitle").textContent = recipe.title || "(Untitled)";
    $("rMatchBadge").textContent = score != null ? `${Math.round(score * 100)}% match` : "";
    $("rSource").textContent = recipe.source || "built-in";

    if (recipe.url) {
      $("rLink").href = recipe.url;
      $("rLink").style.display = "";
    } else {
      $("rLink").style.display = "none";
    }

    $("rTags").innerHTML = (recipe.tags || []).slice(0, 10)
      .map(t => `<span class="tag">${esc(t)}</span>`).join("");

    // Ingredients
    const ingList = formatIngredients(recipe.ingredients || "");
    const ul = $("rIngredients");
    ul.innerHTML = "";
    if (ingList.length) {
      for (const line of ingList) {
        const li = document.createElement("li");
        li.textContent = line;
        ul.appendChild(li);
      }
    } else {
      ul.innerHTML = '<li style="color:var(--text2); font-style:italic">No ingredients listed.</li>';
    }

    // Instructions — formatted as numbered steps
    const inst = recipe.instructions || recipe.steps || "";
    const instSteps = formatInstructions(inst);
    if (instSteps.length > 1) {
      const ol = document.createElement("ol");
      ol.className = "instructions-list";
      for (const step of instSteps) {
        const li = document.createElement("li");
        li.textContent = step;
        ol.appendChild(li);
      }
      $("rInstructions").innerHTML = "";
      $("rInstructions").appendChild(ol);
    } else if (inst.trim()) {
      $("rInstructions").innerHTML = `<div class="instructions-text">${esc(inst)}</div>`;
    } else if (recipe.url) {
      $("rInstructions").innerHTML = `<div class="no-instructions">Instructions not stored. <a href="${esc(recipe.url)}" target="_blank" rel="noopener">View full recipe &rarr;</a></div>`;
    } else {
      $("rInstructions").innerHTML = '<div class="no-instructions">No instructions available for this recipe.</div>';
    }

    $("pPick").value = recipe.title || "";
    selectedBuilt = recipe;
  }

  /* ── Dataset loading (user-triggered, not auto) ── */
  const yieldToBrowser = () => new Promise(r => setTimeout(r, 0));
  let datasetLoading = false;

  async function initDataset() {
    if (datasetLoading) return;
    if (builtVectors && builtRecipes.length) return;
    datasetLoading = true;

    try {
      setStatus("Loading recipes...", "Downloading recipe data...");
      setProgress(5);
      await yieldToBrowser();

      // On mobile, nuke old IndexedDB asset cache first — previous versions cached
      // up to 43 MB of stale data that iOS counts against our memory budget.
      if (isMobile) {
        try { indexedDB.deleteDatabase(ASSET_DB); } catch(e) { /* ignore */ }
        await yieldToBrowser();
      }

      // Always fetch meta fresh (tiny file) — its buildId drives cache-bust params for big files
      const metaRes = await fetch("assets/dataset_meta.json", { cache: "no-cache" });
      if (!metaRes.ok) throw new Error("Could not load dataset_meta.json");
      builtMeta = await metaRes.json();
      const cacheBust = `v=${builtMeta.buildId}_${builtMeta.count}`;
      await yieldToBrowser();

      // Clean up stale cache entries from old builds (desktop only)
      if (!isMobile) {
        try {
          const db = await openAssetDB();
          const tx = db.transaction(ASSET_STORE, "readwrite");
          const store = tx.objectStore(ASSET_STORE);
          const allKeys = await new Promise(r => { const q = store.getAllKeys(); q.onsuccess = () => r(q.result || []); q.onerror = () => r([]); });
          const validKeys = [`recipes_${builtMeta.buildId}_${builtMeta.count}`, `emb_${builtMeta.buildId}_${builtMeta.count}`];
          for (const key of allKeys) {
            if (!validKeys.includes(key)) store.delete(key);
          }
        } catch(e) { /* ignore cleanup errors */ }
      }

      setProgress(12);

      if (isMobile) {
        // ── MOBILE: lean path — only load recipes now, defer embeddings to first search ──
        // recipes.json is ~5 MB. Embeddings (~6 MB) load on first search
        // alongside the quantized model (~6 MB), keeping peak modest.
        setStatus("Loading recipes...", "Downloading recipe list...");
        const recipesRes = await fetch(`assets/recipes.json?${cacheBust}`);
        if (!recipesRes.ok) throw new Error("Could not load recipes.json");
        builtRecipes = await recipesRes.json();
        if (builtRecipes.length !== builtMeta.count) {
          console.warn(`[init] recipes count mismatch: got ${builtRecipes.length}, expected ${builtMeta.count}`);
          builtRecipes = builtRecipes.slice(0, builtMeta.count);
        }
        $("countText").textContent = String(builtRecipes.length);
        setProgress(80);
        await yieldToBrowser();
        // builtVectors loaded lazily via ensureEmbeddings()
      } else {
        // ── DESKTOP: use cached fetch with progress tracking ──
        const recipesKey = `recipes_${builtMeta.buildId}_${builtMeta.count}`;
        let recipesBuf = await fetchOrCache(`assets/recipes.json?${cacheBust}`, recipesKey, 12, 30);
        builtRecipes = JSON.parse(new TextDecoder().decode(new Uint8Array(recipesBuf)));
        if (builtRecipes.length !== builtMeta.count) {
          console.warn(`[init] recipes count mismatch: got ${builtRecipes.length}, expected ${builtMeta.count} — clearing stale cache and refetching`);
          await assetDelete(recipesKey);
          await assetDelete(`emb_${builtMeta.buildId}_${builtMeta.count}`);
          recipesBuf = await fetchOrCache(`assets/recipes.json?${cacheBust}`, recipesKey, 12, 30, true);
          builtRecipes = JSON.parse(new TextDecoder().decode(new Uint8Array(recipesBuf)));
        }
        $("countText").textContent = String(builtRecipes.length);
        await yieldToBrowser();

        setStatus("Loading embeddings...", "Downloading search vectors.");
        setProgress(45);
        await yieldToBrowser();

        const embKey = `emb_${builtMeta.buildId}_${builtMeta.count}`;
        let embBuf = await fetchOrCache(`assets/embeddings.bin?${cacheBust}`, embKey, 45, 50);
        const expectedEmbSize = builtMeta.count * builtMeta.dim * 4;
        if (!embBuf || embBuf.byteLength !== expectedEmbSize) {
          if (embBuf && embBuf.byteLength > expectedEmbSize) {
            console.warn(`[init] embeddings size mismatch: got ${embBuf.byteLength}, expected ${expectedEmbSize} — clearing stale cache and refetching`);
            await assetDelete(embKey);
            embBuf = await fetchOrCache(`assets/embeddings.bin?${cacheBust}`, embKey, 45, 50, true);
          }
          if (!embBuf || embBuf.byteLength < expectedEmbSize) {
            throw new Error("Embeddings file too small or missing.");
          }
        }
        await yieldToBrowser();

        // Create Float32Array — use the buffer directly if aligned, otherwise copy
        if (embBuf.byteLength % 4 === 0 && embBuf instanceof ArrayBuffer) {
          try { builtVectors = new Float32Array(embBuf); } catch(e) {
            const aligned = new ArrayBuffer(embBuf.byteLength);
            new Uint8Array(aligned).set(new Uint8Array(embBuf));
            builtVectors = new Float32Array(aligned);
          }
        } else {
          const aligned = new ArrayBuffer(embBuf.byteLength);
          new Uint8Array(aligned).set(new Uint8Array(embBuf));
          builtVectors = new Float32Array(aligned);
        }
        await yieldToBrowser();
      }

      setProgress(100);
      setStatus("Ready", `${builtMeta.count.toLocaleString()} recipes loaded. Search away!`);
      $("statusDot").classList.add("ok");
      $("statusDot2").classList.add("ok");
      $("statusDot").title = "Dataset loaded";
      setTimeout(() => setProgress(0), 400);

    } catch(e) {
      console.error("[init] failed:", e);
      builtVectors = null; builtRecipes = []; builtMeta = null;
      setProgress(0);
      setStatus("Load failed", String(e?.message || e));
      $("statusDot").classList.add("err");
      $("statusDot2").classList.add("err");
    } finally {
      datasetLoading = false;
    }
  }

  /* ── Lazy-load embeddings (mobile only) ──────── */
  async function ensureEmbeddings() {
    if (builtVectors) return;
    if (!builtMeta) throw new Error("Dataset meta not loaded.");
    setStatus("Loading embeddings...", "Downloading search vectors...");
    setProgress(20);
    await yieldToBrowser();
    const cb = `v=${builtMeta.buildId}_${builtMeta.count}`;
    const embRes = await fetch(`assets/embeddings.bin?${cb}`);
    if (!embRes.ok) throw new Error("Could not load embeddings.bin");
    const embBuf = await embRes.arrayBuffer();
    await yieldToBrowser();
    if (!embBuf || embBuf.byteLength < builtMeta.count * builtMeta.dim * 4) {
      throw new Error("Embeddings file too small or missing.");
    }
    builtVectors = new Float32Array(embBuf);
    await yieldToBrowser();
  }

  /* ══════════════════════════════════════════════
     SEARCH — returns ranked list, supports Next
  ══════════════════════════════════════════════ */
  let selectedBuilt = null;
  let searchResults = [];  // ranked array of { recipe, score, isMine? }
  let searchIdx = 0;       // current position in results

  function showCurrentResult() {
    if (!searchResults.length) {
      $("resultCard").classList.add("hidden");
      setStatus("No match", "Try a different query or adjust filters.");
      return;
    }
    const item = searchResults[searchIdx];
    showResult(item.recipe, item.score);
    $("rResultNum").textContent = `#${searchIdx + 1} of ${searchResults.length}`;
    const multi = searchResults.length > 1;
    $("btnNext").style.display = multi ? "" : "none";
    $("btnPrev").style.display = multi ? "" : "none";
    const src = item.isMine ? "your recipes" : "built-in";
    setStatus("Found", `Result ${searchIdx + 1}/${searchResults.length} from ${src}. ${Math.round(item.score * 100)}% relevance.`);
  }

  // Keyword search — primary on mobile, fallback on desktop
  function keywordSearch(query, diet, tagFilter, maxResults = 50) {
    const words = query.toLowerCase().split(/\s+/).filter(w => w.length > 1);
    if (!words.length) return [];
    const scored = [];
    for (const r of builtRecipes) {
      if (!r) continue;
      if (diet.enabled && diet.preset !== "none" && diet.strictness === "strict" && violatesDiet(r, diet)) continue;
      if (tagFilter && !(r.tags || []).join(" ").toLowerCase().includes(tagFilter)) continue;
      const titleLow = (r.title || "").toLowerCase();
      const ingLow = (r.ingredients || "").toLowerCase();
      const tagsLow = (r.tags || []).join(" ").toLowerCase();
      const instLow = (r.instructions || "").toLowerCase();
      let titleHits = 0, bodyHits = 0;
      for (const w of words) {
        if (titleLow.includes(w)) titleHits++;
        else if (ingLow.includes(w) || tagsLow.includes(w) || instLow.includes(w)) bodyHits++;
      }
      if (titleHits + bodyHits === 0) continue;
      const score = (titleHits / words.length) * 0.6 + (bodyHits / words.length) * 0.25 +
                    ((titleHits + bodyHits === words.length) ? 0.15 : 0);
      const finalScore = (diet.enabled && diet.preset !== "none" && diet.strictness === "soft" && violatesDiet(r, diet))
        ? score * 0.85 : score;
      scored.push({ recipe: r, score: finalScore });
    }
    scored.sort((a, b) => b.score - a.score);
    return scored.slice(0, maxResults);
  }

  async function doSearch() {
    const query = $("q").value.trim();
    if (!query) { setStatus("Ready", "Type what you want to cook."); return; }

    // If dataset not loaded yet, try to load it first
    if (!builtRecipes.length) {
      await initDataset();
      if (!builtRecipes.length) {
        setStatus("Not ready", "Could not load dataset. Tap Load Recipes to retry.");
        return;
      }
    }

    $("btnSearch").disabled = true;
    const tagFilter = ($("tagFilter")?.value || "").trim().toLowerCase();
    const diet = getDietState();
    const queryWords = query.toLowerCase().split(/\s+/).filter(w => w.length > 2);

    try {
      let builtResults = [];
      let usedSemantic = false;

      try {
        // Ensure embeddings are loaded (deferred on mobile)
        await ensureEmbeddings();

        setStatus("Searching...", isMobile ? "Loading AI model (one-time)..." : "Loading embedding model.");
        setProgress(10);
        const qv = await embedText(query);
        await yieldToBrowser();
        setProgress(40);

        setStatus("Searching...", "Scanning recipes.");
        setProgress(60);
        builtResults = bruteForceSearchRanked(qv, queryWords, diet, tagFilter, 50);
        usedSemantic = true;

        // also scan user's own recipes
        if (myRecipes.length) {
          for (const r of myRecipes) {
            if (!r.embedding_b64) continue;
            const bad = violatesDiet({ ...r, instructions: r.steps }, diet);
            if (diet.enabled && diet.preset !== "none" && diet.strictness === "strict" && bad) continue;
            const rv = base64ToFloat(r.embedding_b64);
            let s = cosine(qv, rv);
            if (queryWords.length) {
              const tl = (r.title||"").toLowerCase();
              let th = 0;
              for (const w of queryWords) { if (tl.includes(w)) th++; }
              s += (th / queryWords.length) * 0.04;
            }
            if (diet.enabled && diet.preset !== "none" && diet.strictness === "soft" && bad) s -= 0.05;
            builtResults.push({ recipe: r, score: s, isMine: true });
          }
        }
      } catch(embedErr) {
        // Embedding model failed — fall back to keyword search
        console.warn("[search] embedding failed, using keyword fallback:", embedErr);
        setStatus("Searching...", "Using keyword search.");
        builtResults = keywordSearch(query, diet, tagFilter, 50);
      }

      setProgress(90);
      searchResults = builtResults.sort((a, b) => b.score - a.score).slice(0, 50);
      searchIdx = 0;
      showCurrentResult();
      if (!usedSemantic && searchResults.length) {
        setStatus("Found", `Result ${searchIdx+1}/${searchResults.length}. (keyword mode)`);
      }
      setProgress(0);

    } catch(e) {
      console.error(e);
      setProgress(0);
      setStatus("Search failed", String(e?.message || e));
    } finally {
      $("btnSearch").disabled = false;
    }
  }

  function showNext() {
    if (!searchResults.length) return;
    searchIdx = (searchIdx + 1) % searchResults.length;
    showCurrentResult();
  }
  function showPrev() {
    if (!searchResults.length) return;
    searchIdx = (searchIdx - 1 + searchResults.length) % searchResults.length;
    showCurrentResult();
  }

  $("btnSearch").addEventListener("click", doSearch);
  $("q").addEventListener("keydown", e => { if (e.key === "Enter") doSearch(); });
  $("btnNext").addEventListener("click", showNext);
  $("btnPrev").addEventListener("click", showPrev);

  /* ══════════════════════════════════════════════
     USER DATA STATE
  ══════════════════════════════════════════════ */
  let myRecipes = [];
  let planItems = [];
  let shopItems = [];
  let selectedMyId = null;

  async function refreshUserState() {
    myRecipes = await idbAll(STORE_RECIPES);
    planItems = await idbAll(STORE_PLAN);
    shopItems = await idbAll(STORE_SHOP);
    renderMineList();
    renderPlanList();
    renderShopList();
  }

  /* ── Save built-in to My Recipes ───────────── */
  async function saveBuiltAsMine() {
    if (!selectedBuilt) { alert("Search for a recipe first."); return; }
    const r = selectedBuilt;
    const mine = {
      id: uid(), title: r.title || "", tags: r.tags || [], time: r.time || "",
      ingredients: r.ingredients || "", steps: r.instructions || "",
      notes: r.url ? `Source: ${r.url}` : "",
      updatedAt: Date.now(), embedding_b64: null, embedding_dim: null
    };
    try {
      setStatus("Saving...", "Computing embedding for your copy.");
      const vec = await embedText(myRecipeToEmbedText(mine));
      mine.embedding_b64 = floatToBase64(vec);
      mine.embedding_dim = vec.length;
      await idbPut(STORE_RECIPES, mine);
      await refreshUserState();
      setStatus("Saved", "Recipe added to My Recipes.");
      setTab("MyRecipes");
      loadMineIntoEditor(mine.id);
    } catch(e) {
      console.error(e);
      setStatus("Save failed", String(e?.message||e));
    }
  }
  $("btnSaveAsMine").addEventListener("click", saveBuiltAsMine);

  /* ══════════════════════════════════════════════
     PLANNER
  ══════════════════════════════════════════════ */
  function getRecipeByTitle(title) {
    const t = (title||"").trim().toLowerCase();
    if (!t) return null;
    const mine = myRecipes.find(r => (r.title||"").trim().toLowerCase() === t);
    if (mine) return { kind: "mine", recipe: mine };
    const built = builtRecipes.find(r => (r.title||"").trim().toLowerCase() === t);
    if (built) return { kind: "built", recipe: built };
    return null;
  }

  $("btnAddToPlan").addEventListener("click", () => {
    const title = $("rTitle").textContent.trim();
    if (!title) { alert("Search for a recipe first."); return; }
    $("pPick").value = title;
    setTab("Planner");
  });

  async function addPlanItem() {
    const date = $("pDate").value || todayISO();
    const meal = ($("pMeal").value||"").trim();
    const servings = parseInt($("pServings").value,10)||1;
    const pick = $("pPick").value.trim();
    const found = getRecipeByTitle(pick);
    if (!found) { $("planStatus").textContent = "Recipe not found by title."; return; }
    const plan = {
      id: uid(), date, meal, servings, kind: found.kind,
      recipeId: found.kind==="mine" ? found.recipe.id : (found.recipe.id||null),
      title: found.recipe.title || pick, updatedAt: Date.now(),
    };
    await idbPut(STORE_PLAN, plan);
    planItems.push(plan);
    renderPlanList();
    $("planStatus").textContent = "Added.";
    await rebuildShoppingList();
  }
  $("btnPlanAdd").addEventListener("click", addPlanItem);
  $("pDate").value = todayISO();

  function renderPlanList() {
    const root = $("planList"); root.innerHTML = "";
    if (!planItems.length) { root.innerHTML = '<div class="small" style="padding:8px">No items yet.</div>'; return; }
    const sorted = [...planItems].sort((a,b)=>(a.date+a.meal).localeCompare(b.date+b.meal));
    for (const p of sorted) {
      const el = document.createElement("div"); el.className = "list-item";
      const left = document.createElement("div");
      left.innerHTML = `<h3>${esc(p.title)}</h3><div class="meta">${esc(p.date)} &bull; ${esc(p.meal)} &bull; ${p.servings} servings</div>`;
      const btns = document.createElement("div"); btns.style.display="flex"; btns.style.gap="6px";
      const bDel = document.createElement("button"); bDel.className="btn btn-danger btn-sm"; bDel.textContent="Remove";
      bDel.onclick = async () => { await idbDel(STORE_PLAN, p.id); planItems = planItems.filter(x=>x.id!==p.id); renderPlanList(); await rebuildShoppingList(); };
      btns.appendChild(bDel);
      el.appendChild(left); el.appendChild(btns);
      root.appendChild(el);
    }
  }

  /* ══════════════════════════════════════════════
     SHOPPING LIST
  ══════════════════════════════════════════════ */
  function parseIngredientsLines(text) { return (text||"").split(/\r?\n/).map(s=>s.trim()).filter(Boolean).slice(0,2000); }
  function normalizeIngredientLine(line) { return line.replace(/\s+/g," ").replace(/^[-•*]\s*/,"").trim(); }

  async function rebuildShoppingList() {
    const manual = shopItems.filter(x => x.origin === "manual");
    const map = new Map();
    for (const p of planItems) {
      const r = p.kind==="mine" ? myRecipes.find(x=>x.id===p.recipeId) : builtRecipes.find(x=>(x.title||"")===p.title);
      if (!r) continue;
      const lines = parseIngredientsLines(r.ingredients||"");
      for (const raw of lines) {
        const line = normalizeIngredientLine(raw); if (!line) continue;
        const key = line.toLowerCase();
        if (!map.has(key)) {
          map.set(key, { id: uid(), text: line, checked: false, origin: "plan", sources: [{ date: p.date, meal: p.meal, title: p.title }] });
        } else {
          map.get(key).sources.push({ date: p.date, meal: p.meal, title: p.title });
        }
      }
    }
    shopItems = [...map.values(), ...manual];
    await idbClear(STORE_SHOP);
    for (const it of shopItems) await idbPut(STORE_SHOP, it);
    renderShopList();
  }
  $("btnRebuildShop").addEventListener("click", rebuildShoppingList);

  function renderShopList() {
    const root = $("shopList"); root.innerHTML = "";
    if (!shopItems.length) { root.innerHTML = '<div class="small" style="padding:8px">No items.</div>'; return; }
    const sorted = [...shopItems].sort((a,b) => Number(a.checked)-Number(b.checked));
    for (const it of sorted) {
      const row = document.createElement("div"); row.className = "check-row";
      const cb = document.createElement("input"); cb.type="checkbox"; cb.checked=!!it.checked;
      cb.onchange = async () => { it.checked=cb.checked; await idbPut(STORE_SHOP, it); renderShopList(); };
      const txt = document.createElement("div"); txt.className="text";
      const t = document.createElement("div"); t.style.fontWeight="700"; t.className=it.checked?"strike":""; t.textContent=it.text;
      const m = document.createElement("div"); m.className="small"; m.textContent = it.origin==="plan" ? `From plan (${it.sources?.length||1} recipe(s))` : "Manual";
      txt.appendChild(t); txt.appendChild(m);
      const actions = document.createElement("div"); actions.style.display="flex"; actions.style.gap="4px";
      const bEdit = document.createElement("button"); bEdit.className="btn btn-ghost btn-sm"; bEdit.textContent="Edit";
      bEdit.onclick = async () => { const v=prompt("Edit:",it.text); if(v===null) return; it.text=normalizeIngredientLine(v); await idbPut(STORE_SHOP, it); renderShopList(); };
      const bDel = document.createElement("button"); bDel.className="btn btn-danger btn-sm"; bDel.textContent="Del";
      bDel.onclick = async () => { await idbDel(STORE_SHOP, it.id); shopItems=shopItems.filter(x=>x.id!==it.id); renderShopList(); };
      actions.appendChild(bEdit); actions.appendChild(bDel);
      row.appendChild(cb); row.appendChild(txt); row.appendChild(actions);
      root.appendChild(row);
    }
  }
  $("btnShopAdd").addEventListener("click", async () => {
    const raw=$("shopNew").value.trim(); if(!raw) return;
    const it = { id:uid(), text:normalizeIngredientLine(raw), checked:false, origin:"manual", sources:[] };
    await idbPut(STORE_SHOP, it); shopItems.push(it); $("shopNew").value=""; renderShopList();
  });
  $("shopNew").addEventListener("keydown", e => { if(e.key==="Enter"){e.preventDefault(); $("btnShopAdd").click();} });
  $("btnShopClearDone").addEventListener("click", async () => {
    const rem=shopItems.filter(x=>!x.checked); await idbClear(STORE_SHOP);
    for(const it of rem) await idbPut(STORE_SHOP, it); shopItems=rem; renderShopList();
  });
  $("btnShopWipe").addEventListener("click", async () => {
    if(!confirm("Wipe shopping list?")) return; await idbClear(STORE_SHOP); shopItems=[]; renderShopList();
  });

  /* ══════════════════════════════════════════════
     MY RECIPES CRUD
  ══════════════════════════════════════════════ */
  function normalizeTags(s) { return (s||"").split(",").map(x=>x.trim()).filter(Boolean).slice(0,20); }

  function renderMineList() {
    const root=$("mineList"); root.innerHTML="";
    const q=($("mineSearch").value||"").trim().toLowerCase();
    const items = myRecipes
      .filter(r => !q || [r.title,(r.tags||[]).join(" "),r.ingredients,r.steps].filter(Boolean).join("\n").toLowerCase().includes(q))
      .sort((a,b)=>(b.updatedAt||0)-(a.updatedAt||0));
    if (!items.length) { root.innerHTML='<div class="small" style="padding:8px">No recipes yet.</div>'; return; }
    for (const r of items) {
      const el=document.createElement("div"); el.className="list-item";
      el.innerHTML = `<div><h3>${esc(r.title||"(untitled)")}</h3><div class="meta">${(r.tags||[]).slice(0,4).map(esc).join(", ")||"—"}</div></div>`;
      el.onclick = () => loadMineIntoEditor(r.id);
      root.appendChild(el);
    }
  }
  $("mineSearch").addEventListener("input", renderMineList);

  function showMinePreview(r) {
    $("minePreviewCard").classList.remove("hidden");
    $("mineEditorCard").classList.add("hidden");
    $("mpTitle").textContent = r.title || "(Untitled)";
    $("mpTags").innerHTML = (r.tags || []).slice(0, 10).map(t => `<span class="tag">${esc(t)}</span>`).join("");

    const ingList = formatIngredients(r.ingredients || "");
    const ul = $("mpIngredients"); ul.innerHTML = "";
    if (ingList.length) {
      for (const line of ingList) { const li = document.createElement("li"); li.textContent = line; ul.appendChild(li); }
    } else {
      ul.innerHTML = '<li style="color:var(--text2); font-style:italic">No ingredients.</li>';
    }

    const inst = r.steps || "";
    const instSteps = formatInstructions(inst);
    if (instSteps.length > 1) {
      const ol = document.createElement("ol");
      ol.className = "instructions-list";
      for (const step of instSteps) {
        const li = document.createElement("li");
        li.textContent = step;
        ol.appendChild(li);
      }
      $("mpInstructions").innerHTML = "";
      $("mpInstructions").appendChild(ol);
    } else if (inst.trim()) {
      $("mpInstructions").innerHTML = `<div class="instructions-text">${esc(inst)}</div>`;
    } else {
      $("mpInstructions").innerHTML = '<div class="no-instructions">No instructions.</div>';
    }

    if (r.notes && r.notes.trim()) {
      $("mpNotes").style.display = "";
      $("mpNotesText").textContent = r.notes;
    } else {
      $("mpNotes").style.display = "none";
    }
  }

  function showMineEditor() {
    $("minePreviewCard").classList.add("hidden");
    $("mineEditorCard").classList.remove("hidden");
  }

  function clearMineEditor() {
    selectedMyId=null;
    $("mTitle").value=""; $("mTags").value=""; $("mTime").value="";
    $("mIngredients").value=""; $("mSteps").value=""; $("mNotes").value="";
    $("minePreviewCard").classList.add("hidden");
    $("mineEditorCard").classList.remove("hidden");
  }
  function loadMineIntoEditor(id) {
    const r=myRecipes.find(x=>x.id===id); if(!r) return;
    selectedMyId=id;
    $("mTitle").value=r.title||""; $("mTags").value=(r.tags||[]).join(", ");
    $("mTime").value=r.time||""; $("mIngredients").value=r.ingredients||"";
    $("mSteps").value=r.steps||""; $("mNotes").value=r.notes||"";
    showMinePreview(r);
  }
  $("btnMineEdit").addEventListener("click", showMineEditor);
  $("btnNewMine").addEventListener("click", () => { clearMineEditor(); showMineEditor(); $("mTitle").focus(); });
  $("btnClearMine").addEventListener("click", clearMineEditor);
  $("btnSaveMine").addEventListener("click", async () => {
    const title=$("mTitle").value.trim(), tags=normalizeTags($("mTags").value), time=$("mTime").value.trim();
    const ingredients=$("mIngredients").value.trim(), steps=$("mSteps").value.trim(), notes=$("mNotes").value.trim();
    if (!title && !ingredients && !steps) return alert("Add at least a title.");
    const id=selectedMyId||uid();
    const rec = { id, title, tags, time, ingredients, steps, notes, updatedAt:Date.now(), embedding_b64:null, embedding_dim:null };
    try {
      const vec = await embedText(myRecipeToEmbedText(rec));
      rec.embedding_b64 = floatToBase64(vec); rec.embedding_dim = vec.length;
      await idbPut(STORE_RECIPES, rec); await refreshUserState(); selectedMyId=id;
      showMinePreview(rec); alert("Saved.");
    } catch(e) { console.error(e); alert("Save failed: "+(e?.message||e)); }
  });
  $("btnDeleteMine").addEventListener("click", async () => {
    if (!selectedMyId) return alert("Select a recipe first.");
    if (!confirm("Delete this recipe?")) return;
    await idbDel(STORE_RECIPES, selectedMyId); selectedMyId=null; await refreshUserState(); clearMineEditor();
  });

  /* ══════════════════════════════════════════════
     EXPORTS
  ══════════════════════════════════════════════ */
  function downloadBlob(blob, fn) { const u=URL.createObjectURL(blob); const a=document.createElement("a"); a.href=u; a.download=fn; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(u); }
  function toCSV(rows) {
    const escape = v => {
      const s = String(v ?? "").replace(/\r\n?/g, "\n");
      return /[",\n\r]/.test(s) ? `"${s.replace(/"/g, '""')}"` : s;
    };
    const csv = rows.map(r => r.map(escape).join(",")).join("\r\n");
    return "\uFEFF" + csv;
  }

  function cleanExportText(s) {
    if (!s || typeof s !== "string") return "";
    let t = s.replace(/\u00A0/g, " ").replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, "").trim();
    const parts = t.split(/\s+/);
    const out = [];
    let run = [];
    for (const p of parts) {
      const isSingleLetter = p.length === 1 && /[a-zA-Z]/.test(p);
      if (isSingleLetter) {
        run.push(p);
      } else {
        if (run.length) { out.push(run.join("")); run = []; }
        out.push(p);
      }
    }
    if (run.length) out.push(run.join(""));
    return out.join(" ");
  }

  function formatRecipeForExport(r) {
    const ingLines = formatIngredients(r.ingredients || "");
    const instSteps = formatInstructions(r.steps || r.instructions || "");
    const ingredients = ingLines.length ? ingLines.map(l => `• ${cleanExportText(l)}`).join("\n") : "";
    const instructions = instSteps.length ? instSteps.map((s, i) => `${i + 1}. ${cleanExportText(s)}`).join("\n") : "";
    return { ingredients, instructions };
  }

  function exportMyRecipesCSV() {
    const rows=[["title","tags","time","ingredients","instructions","notes","updatedAt"]];
    for(const r of myRecipes) {
      const { ingredients, instructions } = formatRecipeForExport(r);
      rows.push([cleanExportText(r.title||""),(r.tags||[]).map(cleanExportText).join("; "),r.time||"",ingredients,instructions,cleanExportText(r.notes||""),r.updatedAt?new Date(r.updatedAt).toISOString():""]);
    }
    downloadBlob(new Blob([toCSV(rows)],{type:"text/csv"}), `my_recipes_${todayISO()}.csv`);
  }
  function exportPlanCSV() {
    const rows=[["date","meal","servings","title","kind"]];
    for(const p of [...planItems].sort((a,b)=>(a.date+a.meal).localeCompare(b.date+b.meal))) rows.push([p.date,p.meal,p.servings,cleanExportText(p.title),p.kind]);
    downloadBlob(new Blob([toCSV(rows)],{type:"text/csv"}), `meal_plan_${todayISO()}.csv`);
  }
  function exportShopCSV() {
    const rows=[["item","checked","origin"]];
    for(const it of shopItems) rows.push([cleanExportText(it.text),it.checked?"true":"false",it.origin]);
    downloadBlob(new Blob([toCSV(rows)],{type:"text/csv"}), `shopping_list_${todayISO()}.csv`);
  }
  async function lazyJsPDF() {
    if (!window.jspdf) {
      await new Promise((res, rej) => { const s = document.createElement("script"); s.src = "https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"; s.onload = res; s.onerror = rej; document.head.appendChild(s); });
    }
  }
  async function lazyDocx() {
    if (!window.docx) {
      await new Promise((res, rej) => { const s = document.createElement("script"); s.src = "https://cdn.jsdelivr.net/npm/docx@8.5.0/build/index.umd.js"; s.onload = res; s.onerror = rej; document.head.appendChild(s); });
    }
  }
  async function pdfExport(title, blocks, fn) {
    await lazyJsPDF();
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ unit: "pt", format: "letter" });
    const m = 52, w = 612 - m * 2, lineH = 16, pageH = 792;
    let y = m;

    const draw = (text, font = "helvetica", style = "normal", size = 11) => {
      doc.setFont(font, style);
      doc.setFontSize(size);
      const lines = doc.splitTextToSize(text, w);
      for (const t of lines) {
        if (y > pageH - 48) { doc.addPage(); y = m; }
        doc.text(t, m, y);
        y += lineH;
      }
      y += 4;
    };

    doc.setFontSize(22);
    doc.setFont("helvetica", "bold");
    doc.text(title, m, y);
    y += 28;

    for (const b of blocks) {
      const block = typeof b === "string" ? { type: "body", text: b } : b;
      if (!block.text && block.type !== "divider") continue;
      if (block.type === "title") { draw(block.text, "helvetica", "bold", 18); y += 8; }
      else if (block.type === "h1") { draw(block.text, "helvetica", "bold", 14); y += 4; }
      else if (block.type === "h2") { draw(block.text, "helvetica", "bold", 12); y += 2; }
      else if (block.type === "divider") { y += 12; }
      else { draw(block.text, "helvetica", "normal", 11); }
    }
    doc.save(fn);
  }
  async function exportMyRecipesPDF() {
    const blocks=[];
    for(const r of myRecipes){
      blocks.push({ type: "h1", text: `${cleanExportText(r.title||"(untitled)")}${(r.tags||[]).length ? `  [${(r.tags||[]).map(cleanExportText).join(", ")}]` : ""}${r.time ? "  • "+r.time : ""}` });
      const { ingredients, instructions } = formatRecipeForExport(r);
      if(ingredients){ blocks.push({ type: "h2", text: "Ingredients" }); for(const ln of ingredients.split("\n")) blocks.push({ type: "body", text: ln }); }
      if(instructions){ blocks.push({ type: "h2", text: "Instructions" }); for(const ln of instructions.split("\n")) blocks.push({ type: "body", text: ln }); }
      blocks.push({ type: "divider" });
    }
    await pdfExport("My Recipes", blocks.length ? blocks : [{ type: "body", text: "(empty)" }], `my_recipes_${todayISO()}.pdf`);
  }
  async function exportPlanPDF() {
    const s=[...planItems].sort((a,b)=>(a.date+a.meal).localeCompare(b.date+b.meal));
    const blocks=[];
    let lastDate="";
    for(const p of s){
      if(p.date!==lastDate){
        if(lastDate) blocks.push({ type: "divider" });
        const d=new Date(p.date+"T12:00:00");
        blocks.push({ type: "h1", text: d.toLocaleDateString("en-US",{weekday:"long",month:"short",day:"numeric",year:"numeric"}) });
        lastDate=p.date;
      }
      blocks.push({ type: "body", text: `${p.meal}: ${cleanExportText(p.title)} (${p.servings} servings)` });
    }
    await pdfExport("Meal Plan", blocks.length ? blocks : [{ type: "body", text: "(empty)" }], `meal_plan_${todayISO()}.pdf`);
  }
  async function exportShopPDF() {
    const blocks = shopItems.map(it => ({ type: "body", text: `${it.checked ? "☑" : "☐"} ${cleanExportText(it.text)}` }));
    await pdfExport("Shopping List", blocks.length ? blocks : [{ type: "body", text: "(empty)" }], `shopping_list_${todayISO()}.pdf`);
  }
  async function docxExport(title, blocks, fn) {
    await lazyDocx();
    const { Document, Packer, Paragraph, TextRun } = window.docx;
    const children = [
      new Paragraph({ children: [new TextRun({ text: title, bold: true, size: 36 })], alignment: "center", spacing: { after: 120 } })
    ];
    for (const b of blocks) {
      const block = typeof b === "string" ? { type: "body", text: b } : b;
      if (!block.text && block.type !== "divider") continue;
      if (block.type === "title") children.push(new Paragraph({ children: [new TextRun({ text: block.text, bold: true, size: 28 })], spacing: { before: 120, after: 60 } }));
      else if (block.type === "h1") children.push(new Paragraph({ children: [new TextRun({ text: block.text, bold: true, size: 24 })], spacing: { before: 120, after: 60 } }));
      else if (block.type === "h2") children.push(new Paragraph({ children: [new TextRun({ text: block.text, bold: true, size: 22 })], spacing: { before: 80, after: 40 } }));
      else if (block.type === "divider") children.push(new Paragraph({ children: [new TextRun({ text: "—", color: "CCCCCC" })], spacing: { before: 60, after: 60 } }));
      else children.push(new Paragraph({ children: [new TextRun({ text: block.text, size: 22 })], spacing: { after: 120 } }));
    }
    const doc = new Document({ sections: [{ children }] });
    downloadBlob(await Packer.toBlob(doc), fn);
  }
  async function exportMyRecipesDOCX() {
    const blocks=[];
    for(const r of myRecipes){
      blocks.push({ type: "h1", text: `${cleanExportText(r.title||"(untitled)")}${(r.tags||[]).length ? `  [${(r.tags||[]).map(cleanExportText).join(", ")}]` : ""}${r.time ? "  • "+r.time : ""}` });
      const { ingredients, instructions } = formatRecipeForExport(r);
      if(ingredients){ blocks.push({ type: "h2", text: "Ingredients" }); for(const ln of ingredients.split("\n")) blocks.push({ type: "body", text: ln }); }
      if(instructions){ blocks.push({ type: "h2", text: "Instructions" }); for(const ln of instructions.split("\n")) blocks.push({ type: "body", text: ln }); }
      blocks.push({ type: "divider" });
    }
    await docxExport("My Recipes", blocks.length ? blocks : [{ type: "body", text: "(empty)" }], `my_recipes_${todayISO()}.docx`);
  }
  async function exportPlanDOCX() {
    const s=[...planItems].sort((a,b)=>(a.date+a.meal).localeCompare(b.date+b.meal));
    const blocks=[];
    let lastDate="";
    for(const p of s){
      if(p.date!==lastDate){
        if(lastDate) blocks.push({ type: "divider" });
        const d=new Date(p.date+"T12:00:00");
        blocks.push({ type: "h1", text: d.toLocaleDateString("en-US",{weekday:"long",month:"short",day:"numeric",year:"numeric"}) });
        lastDate=p.date;
      }
      blocks.push({ type: "body", text: `${p.meal}: ${cleanExportText(p.title)} (${p.servings} servings)` });
    }
    await docxExport("Meal Plan", blocks.length ? blocks : [{ type: "body", text: "(empty)" }], `meal_plan_${todayISO()}.docx`);
  }
  async function exportShopDOCX() {
    const blocks = shopItems.map(it => ({ type: "body", text: `${it.checked ? "☑" : "☐"} ${cleanExportText(it.text)}` }));
    await docxExport("Shopping List", blocks.length ? blocks : [{ type: "body", text: "(empty)" }], `shopping_list_${todayISO()}.docx`);
  }

  $("btnExportMineCSV").addEventListener("click", exportMyRecipesCSV);
  $("btnExportMinePDF").addEventListener("click", exportMyRecipesPDF);
  $("btnExportMineDOCX").addEventListener("click", exportMyRecipesDOCX);
  $("btnPlanExportCSV").addEventListener("click", exportPlanCSV);
  $("btnPlanExportPDF").addEventListener("click", exportPlanPDF);
  $("btnPlanExportDOCX").addEventListener("click", exportPlanDOCX);
  $("btnShopExportCSV").addEventListener("click", exportShopCSV);
  $("btnShopExportPDF").addEventListener("click", exportShopPDF);
  $("btnShopExportDOCX").addEventListener("click", exportShopDOCX);

  /* ══════════════════════════════════════════════
     IMPORT / EXPORT ALL / WIPE
  ══════════════════════════════════════════════ */
  function exportAllJSON() {
    const payload = { app:"quick-recipes", version:1, exportedAt:new Date().toISOString(), myRecipes, planItems, shopItems };
    downloadBlob(new Blob([JSON.stringify(payload,null,2)],{type:"application/json"}), `recipe_data_${todayISO()}.json`);
  }
  async function importAllJSON(file) {
    const text = await file.text(); let data;
    try { data = JSON.parse(text); } catch { throw new Error("Invalid JSON."); }
    if (!data || !Array.isArray(data.myRecipes) || !Array.isArray(data.planItems) || !Array.isArray(data.shopItems))
      throw new Error("Missing myRecipes/planItems/shopItems.");
    await idbClear(STORE_RECIPES); await idbClear(STORE_PLAN); await idbClear(STORE_SHOP);
    for (const r of data.myRecipes) await idbPut(STORE_RECIPES, r);
    for (const p of data.planItems) await idbPut(STORE_PLAN, p);
    for (const s of data.shopItems) await idbPut(STORE_SHOP, s);
    await refreshUserState(); alert("Imported.");
  }
  $("btnExportAll").addEventListener("click", exportAllJSON);
  $("btnImportAll").addEventListener("click", () => $("filePick").click());
  $("filePick").addEventListener("change", async e => {
    const file = e.target.files?.[0]; e.target.value=""; if(!file) return;
    try { await importAllJSON(file); } catch(err) { console.error(err); alert("Import failed: "+(err?.message||err)); }
  });
  $("btnWipeUserData").addEventListener("click", async () => {
    if (!confirm("Wipe ALL user data?")) return;
    await idbClear(STORE_RECIPES); await idbClear(STORE_PLAN); await idbClear(STORE_SHOP);
    await refreshUserState(); clearMineEditor(); alert("Wiped.");
  });

  /* ══════════════════════════════════════════════
     STARTUP
  ══════════════════════════════════════════════ */
  await refreshUserState();
  $("pDate").value = todayISO();
  // On mobile, do NOT auto-load. User triggers load by searching. This avoids
  // the init→OOM→reload loop on iOS when HTTP cache serves stale large files.
  if (isMobile) {
    setStatus("Ready", "Tap search to load 3,895 recipes.");
  } else {
    initDataset();
  }
</script>
</body>
</html>
